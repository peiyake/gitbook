# 高速缓存（cache）的工作原理

>本文内容总结自北京大学陆俊林老师的[视频课程](https://www.coursera.org/lecture/jisuanji-zucheng/705-gao-su-huan-cun-de-gong-zuo-yuan-li-eTwwv)

计算机CPU的速度和主存的速度差距越来越大，这样对计算机的快速工作产生很大的影响。而高速缓存（cache）的出现大大缓解了这个局面。

## 计算机存储层次结构

![计算机存储层次结构图](./images/mem.png)

如上图所示，高速缓存（cache）位于CPU和主存之间，那么为什么这样设计就能提高计算机的运行速度呢？答案就是 cache 巧妙利用了程序的**时间局部性**和**空间局部性**。关于者两个局部性的概念举例说明。

例如，有下面一段程序:

![示例程序](./images/for.png)

#### 时间局部性

如上程序所示，2层for循环嵌套用来计算二维数组所有元素的和。其中变量i、j、sum、a在短时间内都会被频繁访问，这就是时间局部性。cache利用这个程序的这个特点，通常会根据一定算法将这种**短时间内会被频繁访问的内存**驻留在cache中，这样就提高了CPU存取这些内存访问速度，从而提高计算机性能。

#### 空间局部性

如上程序所示，二维数组a的内容存储在一段连续的空间中，当CPU准备访问数组a[0][0] 元素的内容时，cache会同时将a[0][0]附近连续的一段数据取到cache中，这样CPU对数组进行的后续访问就可以直接在cache中找到，从而提高访问速度和计算机性能。

#### cache的基本原理

CPU通过cache访问主存内容的过程，如下图所示：

![cache访问主存示意图](./images/cache_mem.png)

* CPU向cache发送一个地址访问请求
* cache发现自己并没有这个地址的数据
* cache向主存去请求这个该地址的数据
* 主存此时返回给cache的数据并非仅仅是请求的地址的单个数据，而是一块内存数据（也就是一个block）
* cache缓存到该block之后，再返回给CPU

1. cache对**空间局部性**的利用
   * cache从主存中取回待访问数据时，同时返回位置相邻的主存单元的数据
   * 以数据块（block）为单位和主存进行数据交换
2. cache对**时间局部性**的利用
   * cache会保存近期被频繁访问的主存单元的数据

![cache访问过程](./images/cache_read.png)

**注意:** 以上操作的所有过程都是由硬件完成的，应用程序只是知道自己访问了哪个地址的数据，但并不知道这个数据是存放在cache中还是主存中。

## cache的组织结构

cache实际上是有SRAM和配套的逻辑电路组成的，SRAM的组织结构如下图所示：


![cache组织结构图](./images/cache_line.png)

这里我们假设，cache block 大小为 16Byte，cache表项也是16.

如上图所示，该图只是精简形式的对cache组织结构的描述：

* 把cache理解成一个表格，该表格有3列，分别是有效位、标签、数据
* 有效位：该为置1，表示此行有缓存数据
* 标签：用来记录请求的地址的高位部分（后面会描述）
* 数据：cache和主存的数据交换不是以字节为单位的，而是以 cache_block 大小为单位的。

根据以上内容，我们假设 执行下面一条指令 

`MOV AL,[2011H]` _地址不考虑段基址_

CPU请求把地址 `2011H`的数据，发现cache中没有，那么cache向主存去请求该数据。那么问题来了，cache获取到主存返回的数据后，**存放在上述表格的哪个位置呢？ 标签的值如何确定？数据应该放在表格的哪一行？**

把地址 `2011H`拆分

```
+-----+-----+-----+-----+
+  N3 + N2  +  N1 +  N0 +
+-----+-----+-----+-----+
+  2     0     1     1 H+
+-----+-----+-----+-----+
```

如上，N0~4 分别表示地址的4bits，那么：

* **cache标签** 的值由 N3 N2来填充
* **N1**的值决定数据存储在哪一行。 （根据假设，N1 4bits表示范围是0~F，跟我们假设的cache表格行数也是16）
* 另外，cache和主存进行数据交换时，是cache_line 对齐的，`2011H`的16字节对齐起始地址是 `2010H`，所以cache的 **data部分** 16个字节，会依次填充 `2010H ~ 201FH`的值，这样通过 N0 就可以定位在 **data部分**找到CPU要获取的数据.

下面是几个例子：

1. cache 未命中，和主存同步数据

![cache1](./images/cache1.png)

2. cache 冲突（行存在，但标签不一致），和主存同步并覆盖原数据

![cache2](./images/cache2.png)

3. cache 未命中，和主存同步数据

![cache3](./images/cache3.png)

4. cache 命中，数据已存在，CPU直接读取

![cache4](./images/cache4.png)


## cache 的写策略

### “cache命中”时的写策略

* `写穿透（Write Through）`：数据同时写入cache和主存。
  - 特点，简单但是慢
* `写返回（Write Back）`：数据只写入cache，仅当数据块被替换时再写入主存。
  - 特点，复杂，但性能好

### “cache未命中”时的写策略

* `写不分配（Write Non-Allocate）`：直接将数据写入主存
* `写分配（Write Allocate）`：将数据所在的块读入cache后，再将数据写入cache。

### 写cache的查找策略

写cache时查找的策略跟上面介绍的读cache的策略是一致的。






